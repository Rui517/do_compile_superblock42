
//** Generates the scicos computational function
//   associated with the block
//12/07/07 Alan Layec
function make_computational42(filename)
    z=cpr.state.z;
    oz=cpr.state.oz;
    outtb=cpr.state.outtb;
    tevts=cpr.state.tevts;
    evtspt=cpr.state.evtspt;
    outptr=cpr.sim.outptr;
    funtyp=cpr.sim.funtyp;
    clkptr=cpr.sim.clkptr;
    ordptr=cpr.sim.ordptr;
    pointi=cpr.state.pointi;
    ztyp=cpr.sim.ztyp;
    zcptr=cpr.sim.zcptr;
    zptr=cpr.sim.zptr;
    ozptr=cpr.sim.ozptr;
    opptr=cpr.sim.opptr;
    opar=cpr.sim.opar;
    rpptr=cpr.sim.rpptr;
    ipptr=cpr.sim.ipptr;
    inpptr=cpr.sim.inpptr;
    funs=cpr.sim.funs;
    xptr=cpr.sim.xptr;
    modptr=cpr.sim.modptr;
    inplnk=cpr.sim.inplnk;
    nblk=cpr.sim.nb;
    outlnk=cpr.sim.outlnk;
    oord=cpr.sim.oord;
    zord=cpr.sim.zord;
    iord=cpr.sim.iord;
    noord=size(cpr.sim.oord,1);
    nzord=size(cpr.sim.zord,1);
    niord=size(cpr.sim.iord,1);

    Indent="  ";
    Indent2=Indent+Indent;
    BigIndent="          ";

    nZ=size(z,"*"); //** index of work in z
    nO=lstsize(oz); //** index of outtb in oz

    stalone=%f

    // Open file to write in
    fd = mopen(filename, "wt");
mputl(["/*"
    "**    SCILAB Computational function"
    "**    Generated by Code_Generation toolbox of Xcos with "+getversion()
    "**    Date : "+date()
    "*/"
    ""
    "/* ---- Headers ---- */"
    "#include <stdio.h>"
    "#include <stdlib.h>"
    "#include <memory.h>"
    "#include <string.h>"
    "#include <math.h>"
    "#include <time.h>"
    "#include <float.h>"
    "#include <limits.h>"
    "#include <ctype.h>"
    "#include <stddef.h>"
    "#include <windows.h>"
    "#include ""machine.h"" "
    "#include ""scicos.h"" "
    "#include ""scicos_malloc.h"" "
    "#include ""scicos_free.h"" "
    "#ifndef max"
    "#define max(a,b) ((a) >= (b) ? (a) : (b))"
    "#endif"
    "#ifndef min"
    "#define min(a,b) ((a) <= (b) ? (a) : (b))"
    "#endif"
     "/* Determine the number of bits that an integer has using the preprocessor */"
    "#if INT_MAX == 32767"
    "/* 16 bits */"
    "#define INTEGER_SIZE 0x0010"
    "#elif INT_MAX == 2147483647"
    "/* 32 bits */"
    "#define INTEGER_SIZE 0x0100"
    "#elif INT_MAX == 9223372036854775807"
    "/* 64 bits */"
    "#define INTEGER_SIZE 0x1000"
    "#else"
    "#error ""Failed to determine the size of an integer"""
    "#endif"
    "/* define our own boolean type */"
    "typedef int bool;"
    "#define true ((bool)1)"
    "#define false ((bool)0)"
    "#define cJSON_False  (1 << 0)"
"#define cJSON_True   (1 << 1)"
"#define cJSON_NULL   (1 << 2)"
"#define cJSON_Number (1 << 3)"
"#define cJSON_String (1 << 4)"
"#define cJSON_Array  (1 << 5)"
"#define cJSON_Object (1 << 6)"

"#define cJSON_IsReference 256"
"#define cJSON_StringIsConst 512"
"typedef struct cJSON"
"{"
    "/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */"
    "struct cJSON *next;"
   " struct cJSON *prev;"
    "/* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */"
    "struct cJSON *child;"

    "/* The type of the item, as above. */"
    "int type;"

    "/* The item"'s string, if type==cJSON_String */"
    "char *valuestring;"
   " /* The item"'s number, if type==cJSON_Number */"
    "int valueint;"
    "/* The item"'s number, if type==cJSON_Number */"
    "double valuedouble;"

    "/* The item"'s name string, if this item is the child of, or is in the list of subitems of an object. */"
    "char *string;"
"} cJSON;"
"typedef struct cJSON_Hooks"
"{"
      "void *(*malloc_fn)(size_t sz);"
      "void (*free_fn)(void *ptr);"
"} cJSON_Hooks;"
"#define cJSON_AddNullToObject(object,name) cJSON_AddItemToObject(object, name, cJSON_CreateNull())"
"#define cJSON_AddTrueToObject(object,name) cJSON_AddItemToObject(object, name, cJSON_CreateTrue())"
"#define cJSON_AddFalseToObject(object,name) cJSON_AddItemToObject(object, name, cJSON_CreateFalse())"
"#define cJSON_AddBoolToObject(object,name,b) cJSON_AddItemToObject(object, name, cJSON_CreateBool(b))"
"#define cJSON_AddNumberToObject(object,name,n) cJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))"
"#define cJSON_AddStringToObject(object,name,s) cJSON_AddItemToObject(object, name, cJSON_CreateString(s))"
"#define cJSON_SetIntValue(object,val) ((object) ? (object)->valueint = (object)->valuedouble = (val) : (val))"
"#define cJSON_SetNumberValue(object,val) ((object) ? (object)->valueint = (object)->valuedouble = (val) : (val))"
"#define cJSON_ArrayForEach(pos, head) for(pos = (head)->child; pos != NULL; pos = pos->next)"
"static cJSON *cJSON_CreateObject(void);"
"static cJSON *cJSON_CreateObject(void);"
"static cJSON *cJSON_New_Item(void);"
"static void   cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item);"
"static cJSON *cJSON_CreateNumber(double num);"
"static void   cJSON_AddItemToArray(cJSON *array, cJSON *item);"
"static void suffix_object(cJSON *prev, cJSON *item);"
"static char* cJSON_strdup(const char* str);"
"static char *cJSON_Print(const cJSON *item);"
"static void cJSON_Delete(cJSON *c);"
"static void jsonc(char *blkname,double total);"
"static cJSON *cJSON_CreateString(const char *string);"
"static const char *global_ep =NULL;"
    ], fd);

    mputl([Protos ; ""], fd);

    mputl(["/* Table of constant values */"
    "static int nrd_"+string(0:maxtotal)'+" = "+string(0:maxtotal)'+";"], fd);

    if maxtotal<10 then
        mputl("static int nrd_10 = 10;", fd);
    end
    if maxtotal<11 then
        mputl("static int nrd_11 = 11;", fd);
    end

    if maxtotal<81 then
        mputl("static int nrd_81 = 81;", fd);
    end
    if maxtotal<82 then
        mputl("static int nrd_82 = 82;", fd);
    end
    if maxtotal<84 then
        mputl("static int nrd_84 = 84;", fd);
    end
    if maxtotal<811 then
        mputl("static int nrd_811 = 811;", fd);
    end
    if maxtotal<812 then
        mputl("static int nrd_812 = 812;", fd);
    end
    if maxtotal<814 then
        mputl("static int nrd_814 = 814;", fd);
    end

    mputl([""
    "/* Some general static variables */"
    "static double zero=0;"
    "static double w[1];"
    "static int aaa=0, bbb=0;"], fd);

    mputl([""
    "/*"+part("-",ones(1,40))+" Block Computational function */ ";
    "int  "+rdnom+"(scicos_block *block, int flag)"
    "{"
    "  /* declaration of local variables for that block struct */"
    "  double* z      = block->z;"
    "  void **ozptr   = block->ozptr;"
    "  void **oparptr = block->oparptr;"
    "  int nopar      = block->nopar;"
    "  double* x      = block->x;"
    "  double* xd     = block->xd;"
    "  double* res    = block->res;"
    "  void** u       = block->inptr;"
    "  void** y       = block->outptr;"
    "  int nevprt     = block->nevprt;"
    "  double* rpar   = block->rpar;"
    "  int nrpar      = block->nrpar;"
    "  int* ipar      = block->ipar;"
    "  int nipar      = block->nipar;"
    "  double* g      = block->g;"
    "  int* mode      = block->mode;"
    "  void **work    = block->work;"
    ""
    "  double t     = get_scicos_time();"
    "  int    phase = get_phase_simulation();"
    ""
    "  int kf = 0;"
    "  int i = 0;"
    "  int* reentryflag = NULL;"
    

       "FILE *fp;"
       "cJSON *json = cJSON_CreateObject();"
    ""], fd);
    
    for kf=1:nblk
        mputl([
        "clock_t start_"+funs(kf)+",end_"+funs(kf)+";"
        "double total_"+funs(kf)+";"], fd);
    end
    
    mputl(["  double *args[100];"
    "  int local_flag;"
    "  int nport;"
    "  void **"+rdnom+"_block_outtbptr;"
    "  scicos_block *block_"+rdnom+";"
    ""
    "  /*  work of blocks are catenated at the end of z */"
    "  work = (void **)(z+"+string(nZ)+");"
    ""
    "  /*  "+rdnom+"_block_outtbptr is catenated at the end of oz */"
    "  "+rdnom+"_block_outtbptr = (void **)(ozptr+"+string(nO)+");"
    ""
    "  /* struct of all blocks are stored in work of that block struct */"
    "  block_"+rdnom+"=(scicos_block*) *block->work;"
    ""
    "  /* Copy inputs in the block outtb */"], fd);


    for i=1:size(capt,1)
        ni=capt(i,3)*capt(i,4); //** dimension of ith input
        if capt(i,5)<>11 then
            mputl(["  memcpy(*("+rdnom+"_block_outtbptr+"+string(capt(i,2)-1)+"),"+...
            "*(u+"+string(capt(i,6)-1)+"),"+...
            string(ni)+"*sizeof("+mat2c_typ(capt(i,5))+"));"], fd);
        else //** Cas cmplx
            mputl(["  memcpy(*("+rdnom+"_block_outtbptr+"+string(capt(i,2)-1)+"),"+...
            "*(u+"+string(capt(i,6)-1)+"),"+...
            string(2*ni)+"*sizeof("+mat2c_typ(capt(i,5))+"));"], fd);
        end
    end

    mputl([""
    "  if (flag != 4 && flag != 6 && flag != 5){"
    "    reentryflag=(int*) ((scicos_block *)(*block->work)+"+string(nblk)+");"
    "    if (*reentryflag==0){"
    "      *reentryflag=1;"], fd);

    for kf=1:nblk
        nin=inpptr(kf+1)-inpptr(kf);  //** number of input ports
        nout=outptr(kf+1)-outptr(kf); //** number of output ports
        nx=xptr(kf+1)-xptr(kf);
        ng=zcptr(kf+1)-zcptr(kf);
        nmode=modptr(kf+1)-modptr(kf);

        //** add comment
        mputl([""
        "      "+get_comment("set_blk",list(funs(kf),funtyp(kf),kf,labels(kf)));], fd);

        for k=1:nin
            lprt=inplnk(inpptr(kf)-1+k);
            mputl(["      block_"+rdnom+"["+string(kf-1)+"].inptr["+string(k-1)+"]  = "+...
            rdnom+"_block_outtbptr["+string(lprt-1)+"];"], fd);
        end
        for k=1:nout
            lprt=outlnk(outptr(kf)-1+k);
            mputl(["      block_"+rdnom+"["+string(kf-1)+"].outptr["+string(k-1)+"] = "+...
            rdnom+"_block_outtbptr["+string(lprt-1)+"];"], fd);
        end
        mputl(["      block_"+rdnom+"["+string(kf-1)+"].z         = &(z["+...
        string(zptr(kf)-1)+"]);"], fd);
        if nx <> 0 then
            mputl(["      block_"+rdnom+"["+string(kf-1)+"].x         = &(x["+...
            string(xptr(kf)-1)+"]);"], fd);
        else
            mputl(["      block_"+rdnom+"["+string(kf-1)+"].x         = &(zero);"
            "      block_"+rdnom+"["+string(kf-1)+"].xd        = w;"], fd);
        end
        if ng <> 0 then
            mputl(["      block_"+rdnom+"["+string(kf-1)+"].g         = &(g["+...
            string(zcptr(kf)-1)+"]);"], fd);
        else
            mputl(["      block_"+rdnom+"["+string(kf-1)+"].g         = &(zero);";], fd);
        end
        if nmode <> 0 then
            mputl(["      block_"+rdnom+"["+string(kf-1)+"].mode      = &(mode["+...
            string(modptr(kf)-1)+"]);"], fd);
        end
        if (part(funs(kf),1:7) ~= "capteur" &...
            part(funs(kf),1:10) ~= "actionneur" &...
            funs(kf) ~= "bidon" &...
            funs(kf) ~= "bidon2") then
            //** rpar **//
            if (rpptr(kf+1)-rpptr(kf)>0) then
                mputl(["      block_"+rdnom+"["+string(kf-1)+"].rpar      = &(rpar["+...
                string(rpptr(kf)-1)+"]);"], fd);
            end
            //** ipar **//
            if (ipptr(kf+1)-ipptr(kf)>0) then
                mputl(["      block_"+rdnom+"["+string(kf-1)+"].ipar      = &(ipar["+...
                string(ipptr(kf)-1)+"]);"], fd);
            end
            //** opar **//
            if (opptr(kf+1)-opptr(kf)>0) then
                nopar = opptr(kf+1)-opptr(kf);
                for k=1:nopar
                    mputl(["      block_"+rdnom+"["+string(kf-1)+"].oparptr["+string(k-1)+...
                    "] = oparptr["+string(opptr(kf)-1+k-1)+"];"], fd);
                end
            end
            //** oz **//
            if (ozptr(kf+1)-ozptr(kf)>0) then
                noz = ozptr(kf+1)-ozptr(kf);
                for k=1:noz
                    mputl(["      block_"+rdnom+"["+string(kf-1)+"].ozptr["+string(k-1)+...
                    "]  = ozptr["+string(ozptr(kf)-1+k-1)+"];"], fd);
                end
            end
        end
        mputl(["      block_"+rdnom+"["+string(kf-1)+"].work      ="+...
        " (void **)(((double *)work)+"+string(kf-1)+");"], fd);
    end

    mputl(["    }"
    "  }"
    ""
    ], fd);

    /////////////////////////////////////////////


    //** find activation number
    blks=find(funtyp>-1);
    evs=[];

    for blk=blks
        for ev=clkptr(blk):clkptr(blk+1)-1
            if funs(blk)=="bidon" then
                if ev > clkptr(howclk) -1
                    evs=[evs,ev];
                end
            end
        end
    end

    //** flag 0
    flag = 0;

    block_has_output=%f
    txt   = [];
    txt22 = [];

    for kf=1:nblk
        nx=xptr(kf+1)-xptr(kf);
        if nx <> 0 then
            txt=[txt;
            "    block_"+rdnom+"["+string(kf-1)+"].xd=&(xd["+...
            string(xptr(kf)-1)+"]);"]
        end
        if part(funs(kf),1:10) == "actionneur" then
            block_has_output=%t
        end
    end
    if txt<>[] then
        txt22=[txt22;
        "    "+get_comment("update_xd",list())
        txt
        ""
        ]
    end
    txt22=[txt22;
    write_code_odoit(1) //** first pass
    write_code_odoit(0) //** second pass
    ]

    if txt22<>[] then
        mputl(["  if (flag == 0) { "+get_comment("flag",list(flag))
        txt22
        "  }"], fd);
    end

    //** flag 1,2,3
    for flag=[1,2,3]

        txt3=[]

        //** continuous time blocks must be activated
        //** for flag 1
        if flag==1 then
            txt = write_code_cdoit(flag);

            if txt <> [] then
                txt3=[txt3;
                Indent+"  switch (nevprt) {"
                ];
                txt3=[txt3;
                Indent2+"  case "+string(0)+" : "+...
                get_comment("ev",list(0))
                "    "+txt;
                ];
                txt3=[txt3;"      break;";""]
            end
        else
            txt=[];
        end

        //** blocks with input discrete event must be activated
        //** for flag 1, 2 and 3
        if size(evs,2)>=1 then
            txt4=[]
            //**
            for ev=evs
                txt2=write_code_doit(ev,flag);
                if txt2<>[] then
                    //** adjust event number because of bidon block
                    new_ev=ev-(clkptr(howclk)-1)
                    //**
                    txt4=[txt4;
                    Indent2+["  case "+string(new_ev)+" : "+...
                    get_comment("ev",list(new_ev))
                    txt2];
                    "      break;";""]
                end
            end

            //**
            if txt == [] then
                if txt4 <> [] then
                    txt3=[txt3;
                    Indent+"  switch (nevprt) {"
                    txt4
                    "    }"];
                end
            else
                txt3=[txt3;
                txt4]
            end
        end

        //**
        if txt <> [] then
            txt3=[txt3;
            "    }"];
        end

        //**
        if txt3<>[] then
            if flag==1 & txt22==[] then
                mputl(["  if (flag == "+string(flag)+") { "+...
                get_comment("flag",list(flag))
                txt3
                "  }"], fd);
            else
                mputl(["  else if (flag == "+string(flag)+") { "+...
                get_comment("flag",list(flag))
                txt3
                "  }"], fd);
            end
        end
    end

    //** flag 9
    ng=zcptr($)-1;
    if (ng ~= 0) then
        flag = 9;
        mputl(["  else if (flag == "+string(flag)+") { "+...
        get_comment("flag",list(flag))], fd);

        txt=[]
        for kf=1:nblk
            if zcptr(kf+1)-zcptr(kf) <> 0 then
                txt=[txt;
                "    block_"+rdnom+"["+string(kf-1)+"].g="+...
                "&(g["+string(zcptr(kf)-1)+"]);"]
            end
        end

        mputl(["    "+get_comment("update_g",list())
        txt
        ""
        write_code_zdoit()
        ], fd);

        mputl(["  }"], fd);
    end

    //** flag 4
    mputl(["  else if (flag == 4) { "+get_comment("flag",list(4))
    "    if ((*block->work=scicos_malloc(sizeof(scicos_block)*"+...
    string(nblk)+"+sizeof(int)))== NULL) return 0;";
    "    reentryflag=(int*) ((scicos_block *)(*block->work)+"+string(nblk)+");"
    "    *reentryflag=0;"
    "    block_"+rdnom+"=(scicos_block*) *block->work;"], fd);

    for kf=1:nblk
        nin=inpptr(kf+1)-inpptr(kf);  //* number of input ports */
        nout=outptr(kf+1)-outptr(kf); //* number of output ports */
        nx=xptr(kf+1)-xptr(kf);
        ng=zcptr(kf+1)-zcptr(kf);
        nmode=modptr(kf+1)-modptr(kf);

        //** add comment
        mputl([""
        "    "+get_comment("set_blk",list(funs(kf),funtyp(kf),kf,labels(kf)));], fd);

        mputl(["    block_"+rdnom+"["+string(kf-1)+"].type   = "+...
        string(funtyp(kf))+";";
        "    block_"+rdnom+"["+string(kf-1)+"].ztyp   = "+...
        string(ztyp(kf))+";";
        "    block_"+rdnom+"["+string(kf-1)+"].ng     = "+...
        string(zcptr(kf+1)-zcptr(kf))+";"], fd);

        if nx <> 0 then
            mputl(["    block_"+rdnom+"["+string(kf-1)+"].nx     = "+...
            string(nx)+";";
            "    block_"+rdnom+"["+string(kf-1)+"].x      = &(x["+...
            string(xptr(kf)-1)+"]);"], fd);
        else
            mputl(["    block_"+rdnom+"["+string(kf-1)+"].nx     = 0;";
            "    block_"+rdnom+"["+string(kf-1)+"].x      = &(zero);"
            "    block_"+rdnom+"["+string(kf-1)+"].xd     = w;"], fd);
        end

        if ng <> 0 then
            mputl(["    block_"+rdnom+"["+string(kf-1)+"].g      = &(g["+...
            string(zcptr(kf)-1)+"]);"], fd);
        else
            mputl(["    block_"+rdnom+"["+string(kf-1)+"].g      = &(zero);";], fd);
        end
        if nmode <> 0 then
            mputl(["    block_"+rdnom+"["+string(kf-1)+"].mode   = &(mode["+...
            string(modptr(kf)-1)+"]);"], fd);
        end
        mputl(["    block_"+rdnom+"["+string(kf-1)+"].nz     = "+...
        string(zptr(kf+1)-zptr(kf))+";";
        "    block_"+rdnom+"["+string(kf-1)+"].noz    = "+...
        string(ozptr(kf+1)-ozptr(kf))+";";
        "    block_"+rdnom+"["+string(kf-1)+"].nrpar  = "+...
        string(rpptr(kf+1)-rpptr(kf))+";";
        "    block_"+rdnom+"["+string(kf-1)+"].nopar  = "+...
        string(opptr(kf+1)-opptr(kf))+";";
        "    block_"+rdnom+"["+string(kf-1)+"].nipar  = "+...
        string(ipptr(kf+1)-ipptr(kf))+";"
        "    block_"+rdnom+"["+string(kf-1)+"].nin    = "+...
        string(inpptr(kf+1)-inpptr(kf))+";";
        "    block_"+rdnom+"["+string(kf-1)+"].nout   = "+...
        string(outptr(kf+1)-outptr(kf))+";";
        "    block_"+rdnom+"["+string(kf-1)+"].nevout = "+...
        string(clkptr(kf+1)-clkptr(kf))+";";
        "    block_"+rdnom+"["+string(kf-1)+"].nmode  = "+...
        string(modptr(kf+1)-modptr(kf))+";"], fd);

        mputl(["    if ((block_"+rdnom+"["+string(kf-1)+"].evout  = "+...
        "calloc(block_"+rdnom+"["+string(kf-1)+"].nevout,sizeof(double)))== NULL) return 0;"], fd);

        //***************************** input port *****************************//
        //** alloc insz/inptr **//
        mputl(["    if ((block_"+rdnom+"["+string(kf-1)+"].insz   = "+...
        "malloc(3*sizeof(int)*block_"+rdnom+"["+string(kf-1)+"].nin))== NULL) return 0;";
        "    if ((block_"+rdnom+"["+string(kf-1)+"].inptr  = "+...
        "malloc(sizeof(void *)*block_"+rdnom+"["+string(kf-1)+"].nin))== NULL) return 0;"], fd);

        //** inptr **//
        for k=1:nin
            lprt=inplnk(inpptr(kf)-1+k);
            mputl(["    block_"+rdnom+"["+string(kf-1)+"].inptr["+string(k-1)+"]  = "+...
            rdnom+"_block_outtbptr["+string(lprt-1)+"];"], fd);
        end

        //** 1st dim **//
        for k=1:nin
            lprt=inplnk(inpptr(kf)-1+k);
            mputl(["    block_"+rdnom+"["+string(kf-1)+"].insz["+string((k-1))+"]   = "+...
            string(size(outtb(lprt),1))+";"], fd);
        end

        //** 2dn dim **//
        for k=1:nin
            lprt=inplnk(inpptr(kf)-1+k);
            mputl(["    block_"+rdnom+"["+string(kf-1)+"].insz["+string((k-1)+nin)+"]   = "+...
            string(size(outtb(lprt),2))+";"], fd);
        end

        //** typ **//
        for k=1:nin
            lprt=inplnk(inpptr(kf)-1+k);
            mputl(["    block_"+rdnom+"["+string(kf-1)+"].insz["+string((k-1)+2*nin)+"]   = "+...
            mat2scs_c_typ(outtb(lprt))+";"], fd);
        end
        //**********************************************************************//

        //***************************** output port *****************************//
        //** alloc outsz/outptr **//
        mputl(["    if ((block_"+rdnom+"["+string(kf-1)+"].outsz  = "+...
        "malloc(3*sizeof(int)*block_"+rdnom+"["+string(kf-1)+"].nout))== NULL) return 0;";
        "    if ((block_"+rdnom+"["+string(kf-1)+"].outptr = "+...
        "malloc(sizeof(void*)*block_"+rdnom+"["+string(kf-1)+"].nout))== NULL) return 0;"], fd);

        //** outptr **//
        for k=1:nout
            lprt=outlnk(outptr(kf)-1+k);
            mputl(["    block_"+rdnom+"["+string(kf-1)+"].outptr["+string(k-1)+"] = "+...
            rdnom+"_block_outtbptr["+string(lprt-1)+"];"], fd);
        end

        //** 1st dim **//
        for k=1:nout
            lprt=outlnk(outptr(kf)-1+k);
            mputl(["    block_"+rdnom+"["+string(kf-1)+"].outsz["+string((k-1))+...
            "]  = "+string(size(outtb(lprt),1))+";"], fd);
        end

        //** 2dn dim **//
        for k=1:nout
            lprt=outlnk(outptr(kf)-1+k);
            mputl(["    block_"+rdnom+"["+string(kf-1)+"].outsz["+string((k-1)+nout)+...
            "]  = "+string(size(outtb(lprt),2))+";"], fd)
        end

        //** typ **//
        for k=1:nout
            lprt=outlnk(outptr(kf)-1+k);
            mputl(["    block_"+rdnom+"["+string(kf-1)+"].outsz["+string((k-1)+2*nout)+...
            "]  = "+mat2scs_c_typ(outtb(lprt))+";"], fd);
        end
        //**********************************************************************//

        mputl(["    block_"+rdnom+"["+string(kf-1)+"].z         = &(z["+...
        string(zptr(kf)-1)+"]);"], fd);

        //***************************** object state *****************************//
        if (ozptr(kf+1)-ozptr(kf)>0) then
            noz = ozptr(kf+1)-ozptr(kf);
            mputl(["    if ((block_"+rdnom+"["+string(kf-1)+"].ozptr = "+...
            "malloc(sizeof(void *)*block_"+rdnom+"["+string(kf-1)+"].noz))== NULL) return 0;";
            "    if ((block_"+rdnom+"["+string(kf-1)+"].ozsz  = "+...
            "malloc(2*sizeof(int)*block_"+rdnom+"["+string(kf-1)+"].noz))== NULL) return 0;";
            "    if ((block_"+rdnom+"["+string(kf-1)+"].oztyp = "+...
            "malloc(sizeof(int)*block_"+rdnom+"["+string(kf-1)+"].noz))== NULL) return 0;";], fd);

            //** ozptr **//
            for k=1:noz
                mputl(["    block_"+rdnom+"["+string(kf-1)+"].ozptr["+string(k-1)+...
                "]  = ozptr["+string(ozptr(kf)-1+k-1)+"];"], fd);
            end

            //** 1st dim **//
            for k=1:noz
                mputl(["    block_"+rdnom+"["+string(kf-1)+"].ozsz["+string(k-1)+...
                "]   = "+string(size(oz(ozptr(kf)-1+k),1))+";"], fd);
            end

            //** 2nd dim **//
            for k=1:noz
                mputl(["    block_"+rdnom+"["+string(kf-1)+"].ozsz["+string(k-1)+...
                "]   = "+string(size(oz(ozptr(kf)-1+k),2))+";"], fd);
            end

            //** typ **//
            for k=1:noz
                mputl(["    block_"+rdnom+"["+string(kf-1)+"].oztyp["+string(k-1)+...
                "]  = "+mat2scs_c_typ(oz(ozptr(kf)-1+k))+";"], fd);
            end
        end
        //************************************************************************//

        if (part(funs(kf),1:7) ~= "capteur" &...
            part(funs(kf),1:10) ~= "actionneur" &...
            funs(kf) ~= "bidon" &...
            funs(kf) ~= "bidon2") then
            if (rpptr(kf+1)-rpptr(kf)>0) then
                mputl(["    block_"+rdnom+"["+string(kf-1)+...
                "].rpar      = &(rpar["+string(rpptr(kf)-1)+"]);"], fd);
            end
            if (ipptr(kf+1)-ipptr(kf)>0) then
                mputl(["    block_"+rdnom+"["+string(kf-1)+...
                "].ipar      = &(ipar["+string(ipptr(kf)-1)+"]);"], fd);
            end
            //** opar
            if (opptr(kf+1)-opptr(kf)>0) then
                mputl(["    if ((block_"+rdnom+"["+string(kf-1)+"].oparptr = "+...
                "malloc(sizeof(void *)*block_"+rdnom+"["+string(kf-1)+"].nopar))== NULL) return 0;";
                "    if ((block_"+rdnom+"["+string(kf-1)+"].oparsz  = "+...
                "malloc(2*sizeof(int)*block_"+rdnom+"["+string(kf-1)+"].nopar))== NULL) return 0;";
                "    if ((block_"+rdnom+"["+string(kf-1)+"].opartyp = "+...
                "malloc(sizeof(int)*block_"+rdnom+"["+string(kf-1)+"].nopar))== NULL) return 0;";
                ], fd);
                nopar = opptr(kf+1)-opptr(kf);
                //** oparptr **//
                for k=1:nopar
                    mputl(["    block_"+rdnom+"["+string(kf-1)+"].oparptr["+string(k-1)+...
                    "]  = oparptr["+string(opptr(kf)-1+k-1)+"];"], fd);
                end
                //** 1st dim **//
                for k=1:nopar
                    mputl(["    block_"+rdnom+"["+string(kf-1)+"].oparsz["+string(k-1)+...
                    "]   = "+string(size(opar(opptr(kf)-1+k),1))+";"], fd);
                end
                //** 2dn dim **//
                for k=1:nopar
                    mputl(["    block_"+rdnom+"["+string(kf-1)+"].oparsz["+string(nopar+(k-1))+...
                    "]   = "+string(size(opar(opptr(kf)-1+k),2))+";"], fd)
                end
                //** typ **//
                for k=1:nopar
                    mputl(["    block_"+rdnom+"["+string(kf-1)+"].opartyp["+string(k-1)+...
                    "]  = "+mat2scs_c_typ(opar(opptr(kf)-1+k))+";"], fd)
                end
            end
        end

        mputl(["    block_"+rdnom+"["+string(kf-1)+...
        "].work      = (void **)(((double *)work)+"+string(kf-1)+");"
        "    block_"+rdnom+"["+string(kf-1)+...
        "].nevprt    = nevprt;"], fd);

    end //for kf=1:nblk

    //** init
    for kf=1:nblk
        //     if or(kf==act) | or(kf==cap) then
        //       if stalone then
        //         txt = call_block42(kf,0,4);
        //         if txt <> [] then
        //           Code=[Code;
        //                 '';
        //                 '    '+txt];
        //         end
        //       end
        //     else
        txt = call_block42(kf,0,4);
        if txt <> [] then
            mputl(["";
            "    "+txt], fd);
        end
        //     end
    end

    //** cst blocks and it's dep
    txt=write_code_idoit()

    if txt<>[] then
        mputl([""
        "    /* initial blocks must be called with flag 1 */"
        txt], fd);
    end
    //   for kf=iord(:,1)'
    // //     if or(kf==act) then
    // //       if stalone then
    // //         txt = call_block42(kf,0,1);
    // //         if txt <> [] then
    // //           Code=[Code;
    // //                 '';
    // //                 '    '+txt];
    // //         end
    // //       end
    // //     else
    //       txt = call_block42(kf,0,1);
    //       if txt <> [] then
    //         Code=[Code;
    //               '';
    //               '    '+txt];
    //       end
    // //     end
    //   end

    mputl(["  }"], fd);

    //** flag 5
    mputl(["  else if (flag == 5) { "+get_comment("flag",list(5))
    "    block_"+rdnom+"=*block->work;"], fd);

    for kf=1:nblk
        nin=inpptr(kf+1)-inpptr(kf);  //* number of input ports */
        nout=outptr(kf+1)-outptr(kf); //* number of output ports */

        //** add comment
        txt=mputl([""
        "    "+get_comment("set_blk",list(funs(kf),funtyp(kf),kf,labels(kf)));], fd);

        for k=1:nin
            lprt=inplnk(inpptr(kf)-1+k);
            mputl(["    block_"+rdnom+"["+string(kf-1)+"].inptr["+string(k-1)+...
            "]  = "+rdnom+"_block_outtbptr["+string(lprt-1)+"];"], fd);
        end
        for k=1:nout
            lprt=outlnk(outptr(kf)-1+k);
            mputl(["    block_"+rdnom+"["+string(kf-1)+"].outptr["+string(k-1)+...
            "] = "+rdnom+"_block_outtbptr["+string(lprt-1)+"];"], fd);
        end
        mputl(["    block_"+rdnom+"["+string(kf-1)+"].z=&(z["+...
        string(zptr(kf)-1)+"]);"], fd);
        if (part(funs(kf),1:7) ~= "capteur" &...
            part(funs(kf),1:10) ~= "actionneur" &...
            funs(kf) ~= "bidon" &...
            funs(kf) ~= "bidon2") then
            //** rpar **//
            if (rpptr(kf+1)-rpptr(kf)>0) then
                mputl(["    block_"+rdnom+"["+string(kf-1)+...
                "].rpar=&(rpar["+string(rpptr(kf)-1)+"]);"], fd);
            end
            //** ipar **//
            if (ipptr(kf+1)-ipptr(kf)>0) then
                mputl(["    block_"+rdnom+"["+string(kf-1)+...
                "].ipar=&(ipar["+string(ipptr(kf)-1)+"]);"], fd);
            end
            //** opar **//
            if (opptr(kf+1)-opptr(kf)>0) then
                nopar = opptr(kf+1)-opptr(kf);
                for k=1:nopar
                    mputl(["    block_"+rdnom+"["+string(kf-1)+"].oparptr["+string(k-1)+...
                    "]  = oparptr["+string(opptr(kf)-1+k-1)+"];"], fd);
                end
            end
            //** oz **//
            if (ozptr(kf+1)-ozptr(kf)>0) then
                noz = ozptr(kf+1)-ozptr(kf);
                for k=1:noz
                    mputl(["    block_"+rdnom+"["+string(kf-1)+"].ozptr["+string(k-1)+...
                    "]  = ozptr["+string(ozptr(kf)-1+k-1)+"];"], fd);
                end
            end
        end

        mputl(["    block_"+rdnom+"["+string(kf-1)+...
        "].work=(void **)(((double *)work)+"+string(kf-1)+");"], fd)
    end

    for kf=1:nblk
        //     if or(kf==act) | or(kf==cap) then
        //       if stalone then
        //         txt = call_block42(kf,0,5);
        //         if txt <> [] then
        //           Code=[Code;
        //                 '';
        //                 '    '+txt];
        //         end
        //       end
        //     else
        txt = call_block42(kf,0,5);
        if txt <> [] then
            mputl(["";
            "    "+txt], fd);
        end
        //     end
    end

    mputl([""
    "    for (kf = 0; kf < "+string(nblk)+"; ++kf) {"
    "      if (block_"+rdnom+"[kf].insz!=NULL) {"
    "        free(block_"+rdnom+"[kf].insz);"
    "      }else {"
    "        break;"
    "      }"
    "      if (block_"+rdnom+"[kf].outsz!=NULL){"
    "        free(block_"+rdnom+"[kf].outsz);"
    "      }else {"
    "        break;"
    "      }"
    "      if (block_"+rdnom+"[kf].nopar!=0){"
    "        if (block_"+rdnom+"[kf].oparptr!=NULL){"
    "          free(block_"+rdnom+"[kf].oparptr);"
    "        }else {"
    "          break;"
    "        }"
    "        if (block_"+rdnom+"[kf].oparsz!=NULL){"
    "          free(block_"+rdnom+"[kf].oparsz);"
    "        }else {"
    "          break;"
    "        }"
    "        if (block_"+rdnom+"[kf].opartyp!=NULL){"
    "          free(block_"+rdnom+"[kf].opartyp);"
    "        }else {"
    "          break;"
    "        }"
    "      }"
    "      if (block_"+rdnom+"[kf].noz!=0){"
    "        if (block_"+rdnom+"[kf].ozptr!=NULL){"
    "          free(block_"+rdnom+"[kf].ozptr);"
    "        }else {"
    "          break;"
    "        }"
    "        if (block_"+rdnom+"[kf].ozsz!=NULL){"
    "          free(block_"+rdnom+"[kf].ozsz);"
    "        }else {"
    "          break;"
    "        }"
    "        if (block_"+rdnom+"[kf].oztyp!=NULL){"
    "          free(block_"+rdnom+"[kf].oztyp);"
    "        }else {"
    "          break;"
    "        }"
    "      }"
    "      if (block_"+rdnom+"[kf].evout!=NULL){"
    "        free(block_"+rdnom+"[kf].evout);"
    "      }else {"
    "        break;"
    "      }"
    "    }"
    "    scicos_free(block_"+rdnom+");"
    "  }"
    ""], fd);

    for i=1:size(actt,1)
        ni=actt(i,3)*actt(i,4); // dimension of ith input
        if actt(i,5)<>11 then
            mputl(["  memcpy(*(y+"+string(actt(i,6)-1)+"),"+...
            "*("+rdnom+"_block_outtbptr+"+string(actt(i,2)-1)+"),"+...
            string(ni)+"*sizeof("+mat2c_typ(actt(i,5))+"));"], fd);
        else //** Cas cmplx
            mputl(["  memcpy(*(y+"+string(actt(i,6)-1)+"),"+...
            "*("+rdnom+"_block_outtbptr+"+string(actt(i,2)-1)+"),"+...
            string(2*ni)+"*sizeof("+mat2c_typ(actt(i,5))+"));"], fd);
        end
    end

    //**
     for kf=1:nblk
    mputl(["cJSON_AddNumberToObject(json,"""+funs(kf)+":"",total_"+funs(kf)+");"], fd);
    end
     mputl([
    "{"
    "fp = fopen(""C:\\Users\\32914\\Desktop\\test\\3\\create.json"",""w"");"
    "fwrite(cJSON_Print(json),strlen(cJSON_Print(json)),1,fp);"
    "fclose(fp);"
    "}"
    "cJSON_Delete(json);"
    
    "  return 0;"
    ""
    "} /* "+rdnom+" */"
 "const char *cJSON_GetErrorPtr(void)"
"{"
"    return global_ep;"
"}"
""
"/* case insensitive strcmp */"
"static int cJSON_strcasecmp(const char *s1, const char *s2)"
"{"
"    if (!s1)"
"    {"
"        return (s1 == s2) ? 0 : 1; /* both NULL? */"
"    }"
"    if (!s2)"
"    {"
"        return 1;"
"    }"
"    for(; tolower(*(const unsigned char *)s1) == tolower(*(const unsigned char *)s2); ++s1, ++s2)"
"    {"
"        if (*s1 == "'\0"')"
"        {"
"            return 0;"
"        }"
"    }"
""
"    return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);"
"}"
"static void *(*cJSON_malloc)(size_t sz) = malloc;"
"static void (*cJSON_free)(void *ptr) = free;"
"static char* cJSON_strdup(const char* str)"
"{"
"    size_t len = 0;"
"    char *copy = NULL;"
""
"    len = strlen(str) + 1;"
"    if (!(copy = (char*)cJSON_malloc(len)))"
"    {"
"        return NULL;"
"    }"
"    memcpy(copy, str, len);"
""
"    return copy;"
"}"
""
"void cJSON_InitHooks(cJSON_Hooks* hooks)"
"{"
"    if (!hooks)"
"    {"
"        /* Reset hooks */"
"        cJSON_malloc = malloc;"
"        cJSON_free = free;"
"        return;"
"    }"
""
"    cJSON_malloc = (hooks->malloc_fn) ? hooks->malloc_fn : malloc;"
"    cJSON_free = (hooks->free_fn) ? hooks->free_fn : free;"
"}"
""
"/* Internal constructor. */"
"static cJSON *cJSON_New_Item(void)"
"{"
"    cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));"
"    if (node)"
"    {"
"        memset(node, "'\0"', sizeof(cJSON));"
"    }"
""
"    return node;"
"}"
""
"/* Delete a cJSON structure. */"
"void cJSON_Delete(cJSON *c)"
"{"
"    cJSON *next = NULL;"
"    while (c)"
"    {"
"        next = c->next;"
"        if (!(c->type & cJSON_IsReference) && c->child)"
"        {"
"            cJSON_Delete(c->child);"
"        }"
"        if (!(c->type & cJSON_IsReference) && c->valuestring)"
"        {"
"            cJSON_free(c->valuestring);"
"        }"
"        if (!(c->type & cJSON_StringIsConst) && c->string)"
"        {"
"            cJSON_free(c->string);"
"        }"
"        cJSON_free(c);"
"        c = next;"
"    }"
"}"
""
"/* Parse the input text to generate a number, and populate the result into item. */"
"static const char *parse_number(cJSON *item, const char *num)"
"{"
"    double n = 0;"
"    double sign = 1;"
"    double scale = 0;"
"    int subscale = 0;"
"    int signsubscale = 1;"
""
"    /* Has sign? */"
"    if (*num == "'-"')"
"    {        sign = -1;"
"        num++;"
"    }"
"    /* is zero */"
"    if (*num == "'0"')"
"    {"
"        num++;"
"    }"
"    /* Number? */"
"    if ((*num >= "'1"') && (*num <= "'9"'))"
"    {"
"        do"
"        {"
"            n = (n * 10.0) + (*num++ - "'0"');"
"        }"
"        while ((*num >= "'0"') && (*num<="'9"'));"
"    }"
"    /* Fractional part? */"
"    if ((*num == "'."') && (num[1] >= "'0"') && (num[1] <= "'9"'))"
"    {        num++;"
"        do"
"        {"
"            n = (n  *10.0) + (*num++ - "'0"');"
"            scale--;"
"        } while ((*num >= "'0"') && (*num <= "'9"'));"
"    }"
"    /* Exponent? */"
"    if ((*num == "'e"') || (*num == "'E"'))"
"    {"
"        num++;"
"        /* With sign? */"
"        if (*num == "'+"')"
"        {"
"            num++;"
"        }"
"        else if (*num == "'-"')"
"        {"
"            signsubscale = -1;"
"            num++;"
"        }"
"        /* Number? */"
"        while ((*num>="'0"') && (*num<="'9"'))"
"        {"
"            subscale = (subscale * 10) + (*num++ - "'0"');"
"        }"
"    }"
""
"    /* number = +/- number.fraction * 10^+/- exponent */"
"    n = sign * n * pow(10.0, (scale + subscale * signsubscale));"
""
"    item->valuedouble = n;"
"    item->valueint = (int)n;"
"    item->type = cJSON_Number;"
""
"    return num;"
"}"
""
"/* calculate the next largest power of 2 */"
"static int pow2gt (int x)"
"{"
"    --x;"
""
"    x |= x >> 1;"
"    x |= x >> 2;"
"    x |= x >> 4;"
"#if INTEGER_SIZE & 0x1110 /* at least 16 bit */"
"    x |= x >> 8;"
"#endif"
"#if INTEGER_SIZE & 0x1100 /* at least 32 bit */"
"    x |= x >> 16;"
"#endif"
"#if INT_SIZE & 0x1000 /* 64 bit */"
"    x |= x >> 32;"
"#endif"
""
"    return x + 1;"
"}"
""
"typedef struct"
"{"
"    char *buffer;"
"    int length;"
"    int offset;"
"} printbuffer;"
""
"/* realloc printbuffer if necessary to have at least ""needed"" bytes more */"
"static char* ensure(printbuffer *p, int needed)"
"{"
"    char *newbuffer = NULL;"
"    int newsize = 0;"
"    if (!p || !p->buffer)"
"    {"
"        return NULL;"
"    }"
"    needed += p->offset;"
"    if (needed <= p->length)"
"    {"
"        return p->buffer + p->offset;"
"    }"
""
"    newsize = pow2gt(needed);"
"    newbuffer = (char*)cJSON_malloc(newsize);"
"    if (!newbuffer)"
"    {"
"        cJSON_free(p->buffer);"
"        p->length = 0;"
"        p->buffer = NULL;"
""
"        return NULL;"
"    }"
"    if (newbuffer)"
"    {"
"        memcpy(newbuffer, p->buffer, p->length);"
"    }"
"    cJSON_free(p->buffer);"
"    p->length = newsize;"
"    p->buffer = newbuffer;"
""
"    return newbuffer + p->offset;"
"}"
""
"/* calculate the new length of the string in a printbuffer */"
"static int update(const printbuffer *p)"
"{"
"    char *str = NULL;"
"    if (!p || !p->buffer)"
"    {"
"        return 0;"
"    }"
"    str = p->buffer + p->offset;"
""
"    return p->offset + strlen(str);"
"}"
""
"/* Render the number nicely from the given item into a string. */"
"static char *print_number(const cJSON *item, printbuffer *p)"
"{"
"    char *str = NULL;"
"    double d = item->valuedouble;"
"    /* special case for 0. */"
"    if (d == 0)"
"    {"
"        if (p)"
"        {"
"            str = ensure(p, 2);"
"        }"
"        else"
"        {"
"            str = (char*)cJSON_malloc(2);"
"        }"
"        if (str)"
"        {"
"            strcpy(str,""0"");"
"        }"
"    }"
"    /* value is an int */"
"    else if ((fabs(((double)item->valueint) - d) <= DBL_EPSILON) && (d <= INT_MAX) && (d >= INT_MIN))"
"    {"
"        if (p)"
"        {"
"            str = ensure(p, 21);"
"        }"
"        else"
"        {"
"            /* 2^64+1 can be represented in 21 chars. */"
"            str = (char*)cJSON_malloc(21);"
"        }"
"        if (str)"
"        {"
"            sprintf(str, ""%d"", item->valueint);"
"        }"
"    }"
"    /* value is a floating point number */"
"    else"
"    {"
"        if (p)"
"        {"
"            /* This is a nice tradeoff. */"
"            str = ensure(p, 64);"
"        }"
"        else"
"        {"
"            /* This is a nice tradeoff. */"
"            str=(char*)cJSON_malloc(64);"
"        }"
"        if (str)"
"        {"
"            /* This checks for NaN and Infinity */"
"            if ((d * 0) != 0)"
"            {"
"                sprintf(str, ""null"");"
"            }"
"            else if ((fabs(floor(d) - d) <= DBL_EPSILON) && (fabs(d) < 1.0e60))"
"            {"
"                sprintf(str, ""%.0f"", d);"
"            }"
"            else if ((fabs(d) < 1.0e-6) || (fabs(d) > 1.0e9))"
"            {"
"                sprintf(str, ""%e"", d);"
"            }"
"            else"
"            {"
"                sprintf(str, ""%f"", d);"
"            }"
"        }"
"    }"
"    return str;"
"}"
""
"/* parse 4 digit hexadecimal number */"
"static unsigned parse_hex4(const char *str)"
"{"
"    unsigned h = 0;"
"    /* first digit */"
"    if ((*str >= "'0"') && (*str <= "'9"'))"
"    {"
"        h += (*str) - "'0"';"
"    }"
"    else if ((*str >= "'A"') && (*str <= "'F"'))"
"    {"
"        h += 10 + (*str) - "'A"';"
"    }"
"    else if ((*str >= "'a"') && (*str <= "'f"'))"
"    {"
"        h += 10 + (*str) - "'a"';"
"    }"
"    else /* invalid */"
"    {"
"        return 0;"
"    }"
""
""
"    /* second digit */"
"    h = h << 4;"
"    str++;"
"    if ((*str >= "'0"') && (*str <= "'9"'))"
"    {"
"        h += (*str) - "'0"';"
"    }"
"    else if ((*str >= "'A"') && (*str <= "'F"'))"
"    {"
"        h += 10 + (*str) - "'A"';"
"    }"
"    else if ((*str >= "'a"') && (*str <= "'f"'))"
"    {"
"        h += 10 + (*str) - "'a"';"
"    }"
"    else /* invalid */"
"    {"
"        return 0;"
"    }"
""
"    /* third digit */"
"    h = h << 4;"
"    str++;"
"    if ((*str >= "'0"') && (*str <= "'9"'))"
"    {"
"        h += (*str) - "'0"';"
"    }"
"    else if ((*str >= "'A"') && (*str <= "'F"'))"
"    {"
"        h += 10 + (*str) - "'A"';"
"    }"
"    else if ((*str >= "'a"') && (*str <= "'f"'))"
"    {"
"        h += 10 + (*str) - "'a"';"
"    }"
"    else /* invalid */"
"    {"
"        return 0;"
"    }"
""
"    /* fourth digit */"
"    h = h << 4;"
"    str++;"
"    if ((*str >= "'0"') && (*str <= "'9"'))"
"    {"
"        h += (*str) - "'0"';"
"    }"
"    else if ((*str >= "'A"') && (*str <= "'F"'))"
"    {"
"        h += 10 + (*str) - "'A"';"
"    }"
"    else if ((*str >= "'a"') && (*str <= "'f"'))"
"    {"
"        h += 10 + (*str) - "'a"';"
"    }"
"    else /* invalid */"
"    {"
"        return 0;"
"    }"
""
"    return h;"
"}"
""
"/* first bytes of UTF8 encoding for a given length in bytes */"
"static const unsigned char firstByteMark[7] ="
"{"
"    0x00, /* should never happen */"
"    0x00, /* 0xxxxxxx */"
"    0xC0, /* 110xxxxx */"
"    0xE0, /* 1110xxxx */"
"    0xF0, /* 11110xxx */"
"    0xF8,"
"    0xFC"
"};"
""
"/* Parse the input text into an unescaped cstring, and populate item. */"
"static const char *parse_string(cJSON *item, const char *str, const char **ep)"
"{"
"    const char *ptr = str + 1;"
"    const char *end_ptr =str + 1;"
"    char *ptr2 = NULL;"
"    char *out = NULL;"
"    int len = 0;"
"    unsigned uc = 0;"
"    unsigned uc2 = 0;"
""
"    /* not a string! */"
"    if (*str != "'\"""')"
"    {"
"        *ep = str;"
"        return NULL;"
"    }"
""
"    while ((*end_ptr != "'\"""') && *end_ptr && ++len)"
"    {"
"        if (*end_ptr++ == "'\\"')"
"        {"
"            if (*end_ptr == "'\0"')"
"            {"
"                /* prevent buffer overflow when last input character is a backslash */"
"                return NULL;"
"            }"
"            /* Skip escaped quotes. */"
"            end_ptr++;"
"        }"
"    }"
""
"    /* This is at most how long we need for the string, roughly. */"
"    out = (char*)cJSON_malloc(len + 1);"
"    if (!out)"
"    {"
"        return NULL;"
"    }"
"    item->valuestring = out; /* assign here so out will be deleted during cJSON_Delete() later */"
"    item->type = cJSON_String;"
""
"    ptr = str + 1;"
"    ptr2 = out;"
"    /* loop through the string literal */"
"    while (ptr < end_ptr)"
"    {"
"        if (*ptr != "'\\"')"
"        {"
"            *ptr2++ = *ptr++;"
"        }"
"        /* escape sequence */"
"        else"
"        {"
"            ptr++;"
"            switch (*ptr)"
"            {"
"                case "'b"':"
"                    *ptr2++ = "'\b"';"
"                    break;"
"                case "'f"':"
"                    *ptr2++ = "'\f"';"
"                    break;"
"                case "'n"':"
"                    *ptr2++ = "'\n"';"
"                    break;"
"                case "'r"':"
"                    *ptr2++ = "'\r"';"
"                    break;"
"                case "'t"':"
"                    *ptr2++ = "'\t"';"
"                    break;"
"                case "'\"""':"
"                case "'\\"':"
"                case "'/"':"
"                    *ptr2++ = *ptr;"
"                    break;"
"                case "'u"':"
"                    /* transcode utf16 to utf8. See RFC2781 and RFC3629. */"
"                    uc = parse_hex4(ptr + 1); /* get the unicode char. */"
"                    ptr += 4;"
"                    if (ptr >= end_ptr)"
"                    {"
"                        /* invalid */"
"                        *ep = str;"
"                        return NULL;"
"                    }"
"                    /* check for invalid. */"
"                    if (((uc >= 0xDC00) && (uc <= 0xDFFF)) || (uc == 0))"
"                    {"
"                        *ep = str;"
"                        return NULL;"
"                    }"
""
"                    /* UTF16 surrogate pairs. */"
"                    if ((uc >= 0xD800) && (uc<=0xDBFF))"
"                    {"
"                        if ((ptr + 6) > end_ptr)"
"                        {"
"                            /* invalid */"
"                            *ep = str;"
"                            return NULL;"
"                        }"
"                        if ((ptr[1] != "'\\"') || (ptr[2] != "'u"'))"
"                        {"
"                            /* missing second-half of surrogate. */"
"                            *ep = str;"
"                            return NULL;"
"                        }"
"                        uc2 = parse_hex4(ptr + 3);"
"                        ptr += 6; /* \uXXXX */"
"                        if ((uc2 < 0xDC00) || (uc2 > 0xDFFF))"
"                        {"
"                            /* invalid second-half of surrogate. */"
"                            *ep = str;"
"                            return NULL;"
"                        }"
"                        /* calculate unicode codepoint from the surrogate pair */"
"                        uc = 0x10000 + (((uc & 0x3FF) << 10) | (uc2 & 0x3FF));"
"                    }"
""
"                    /* encode as UTF8"
"                     * takes at maximum 4 bytes to encode:"
"                     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */"
"                    len = 4;"
"                    if (uc < 0x80)"
"                    {"
"                        /* normal ascii, encoding 0xxxxxxx */"
"                        len = 1;"
"                    }"
"                    else if (uc < 0x800)"
"                    {"
"                        /* two bytes, encoding 110xxxxx 10xxxxxx */"
"                        len = 2;"
"                    }"
"                    else if (uc < 0x10000)"
"                    {"
"                        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */"
"                        len = 3;"
"                    }"
"                    ptr2 += len;"
""
"                    switch (len) {"
"                        case 4:"
"                            /* 10xxxxxx */"
"                            *--ptr2 = ((uc | 0x80) & 0xBF);"
"                            uc >>= 6;"
"                        case 3:"
"                            /* 10xxxxxx */"
"                            *--ptr2 = ((uc | 0x80) & 0xBF);"
"                            uc >>= 6;"
"                        case 2:"
"                            /* 10xxxxxx */"
"                            *--ptr2 = ((uc | 0x80) & 0xBF);"
"                            uc >>= 6;"
"                        case 1:"
"                            /* depending on the length in bytes this determines the"
"                             * encoding ofthe first UTF8 byte */"
"                            *--ptr2 = (uc | firstByteMark[len]);"
"                    }"
"                    ptr2 += len;"
"                    break;"
"                default:"
"                    *ep = str;"
"                    return NULL;"
"            }"
"            ptr++;"
"        }"
"    }"
"    *ptr2 = "'\0"';"
"    if (*ptr == "'\"""')"
"    {"
"        ptr++;"
"    }"
""
"    return ptr;"
"}"
""
"/* Render the cstring provided to an escaped version that can be printed. */"
"static char *print_string_ptr(const char *str, printbuffer *p)"
"{"
"    const char *ptr = NULL;"
"    char *ptr2 = NULL;"
"    char *out = NULL;"
"    int len = 0;"
"    bool flag = false;"
"    unsigned char token = "'\0"';"
""
"    /* empty string */"
"    if (!str)"
"    {"
"        if (p)"
"        {"
"            out = ensure(p, 3);"
"        }"
"        else"
"        {"
"            out = (char*)cJSON_malloc(3);"
"        }"
"        if (!out)"
"        {"
"            return NULL;"
"        }"
"        strcpy(out, ""\""\"""");"
""
"        return out;"
"    }"
""
"    /* set ""flag"" to 1 if something needs to be escaped */"
"    for (ptr = str; *ptr; ptr++)"
"    {"
"        flag |= (((*ptr > 0) && (*ptr < 32)) /* unprintable characters */"
"                || (*ptr == "'\"""') /* double quote */"
"                || (*ptr == "'\\"')) /* backslash */"
"            ? 1"
"            : 0;"
"    }"
"    /* no characters have to be escaped */"
"    if (!flag)"
"    {"
"        len = ptr - str;"
"        if (p)"
"        {"
"            out = ensure(p, len + 3);"
"        }"
"        else"
"        {"
"            out = (char*)cJSON_malloc(len + 3);"
"        }"
"        if (!out)"
"        {"
"            return NULL;"
"        }"
""
"        ptr2 = out;"
"        *ptr2++ = "'\"""';"
"        strcpy(ptr2, str);"
"        ptr2[len] = "'\"""';"
"        ptr2[len + 1] = "'\0"';"
""
"        return out;"
"    }"
""
"    ptr = str;"
"    /* calculate additional space that is needed for escaping */"
"    while ((token = *ptr) && ++len)"
"    {"
"        if (strchr(""\""\\\b\f\n\r\t"", token))"
"        {"
"            len++; /* +1 for the backslash */"
"        }"
"        else if (token < 32)"
"        {"
"            len += 5; /* +5 for \uXXXX */"
"        }"
"        ptr++;"
"    }"
""
"    if (p)"
"    {"
"        out = ensure(p, len + 3);"
"    }"
"    else"
"    {"
"        out = (char*)cJSON_malloc(len + 3);"
"    }"
"    if (!out)"
"    {"
"        return NULL;"
"    }"
""
"    ptr2 = out;"
"    ptr = str;"
"    *ptr2++ = "'\"""';"
"    /* copy the string */"
"    while (*ptr)"
"    {"
"        if (((unsigned char)*ptr > 31) && (*ptr != "'\"""') && (*ptr != "'\\"'))"
"        {"
"            /* normal character, copy */"
"            *ptr2++ = *ptr++;"
"        }"
"        else"
"        {"
"            /* character needs to be escaped */"
"            *ptr2++ = "'\\"';"
"            switch (token = *ptr++)"
"            {"
"                case "'\\"':"
"                    *ptr2++ = "'\\"';"
"                    break;"
"                case "'\"""':"
"                    *ptr2++ = "'\"""';"
"                    break;"
"                case "'\b"':"
"                    *ptr2++ = "'b"';"
"                    break;"
"                case "'\f"':"
"                    *ptr2++ = "'f"';"
"                    break;"
"                case "'\n"':"
"                    *ptr2++ = "'n"';"
"                    break;"
"                case "'\r"':"
"                    *ptr2++ = "'r"';"
"                    break;"
"                case "'\t"':"
"                    *ptr2++ = "'t"';"
"                    break;"
"                default:"
"                    /* escape and print as unicode codepoint */"
"                    sprintf(ptr2, ""u%04x"", token);"
"                    ptr2 += 5;"
"                    break;"
"            }"
"        }"
"    }"
"    *ptr2++ = "'\"""';"
"    *ptr2++ = "'\0"';"
""
"    return out;"
"}"
""
"/* Invoke print_string_ptr (which is useful) on an item. */"
"static char *print_string(const cJSON *item, printbuffer *p)"
"{"
"    return print_string_ptr(item->valuestring, p);"
"}"
""
"/* Predeclare these prototypes. */"
"static const char *parse_value(cJSON *item, const char *value, const char **ep);"
"static char *print_value(const cJSON *item, int depth, bool fmt, printbuffer *p);"
"static const char *parse_array(cJSON *item, const char *value, const char **ep);"
"static char *print_array(const cJSON *item, int depth, bool fmt, printbuffer *p);"
"static const char *parse_object(cJSON *item, const char *value, const char **ep);"
"static char *print_object(const cJSON *item, int depth, bool fmt, printbuffer *p);"
""
"/* Utility to jump whitespace and cr/lf */"
"static const char *skip(const char *in)"
"{"
"    while (in && *in && ((unsigned char)*in<=32))"
"    {"
"        in++;"
"    }"
""
"    return in;"
"}"
""
"/* Parse an object - create a new root, and populate. */"
"cJSON *cJSON_ParseWithOpts(const char *value, const char **return_parse_end, bool require_null_terminated)"
"{"
"    const char *end = NULL;"
"    /* use global error pointer if no specific one was given */"
"    const char **ep = return_parse_end ? return_parse_end : &global_ep;"
"    cJSON *c = cJSON_New_Item();"
"    *ep = NULL;"
"    if (!c) /* memory fail */"
"    {"
"        return NULL;"
"    }"
""
"    end = parse_value(c, skip(value), ep);"
"    if (!end)"
"    {"
"        /* parse failure. ep is set. */"
"        cJSON_Delete(c);"
"        return NULL;"
"    }"
""
"    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */"
"    if (require_null_terminated)"
"    {"
"        end = skip(end);"
"        if (*end)"
"        {"
"            cJSON_Delete(c);"
"            *ep = end;"
"            return NULL;"
"        }"
"    }"
"    if (return_parse_end)"
"    {"
"        *return_parse_end = end;"
"    }"
""
"    return c;"
"}"
""
"/* Default options for cJSON_Parse */"
"cJSON *cJSON_Parse(const char *value)"
"{"
"    return cJSON_ParseWithOpts(value, 0, 0);"
"}"
""
"/* Render a cJSON item/entity/structure to text. */"
"char *cJSON_Print(const cJSON *item)"
"{"
"    return print_value(item, 0, 1, 0);"
"}"
""
"char *cJSON_PrintUnformatted(const cJSON *item)"
"{"
"    return print_value(item, 0, 0, 0);"
"}"
""
"char *cJSON_PrintBuffered(const cJSON *item, int prebuffer, bool fmt)"
"{"
"    printbuffer p;"
"    p.buffer = (char*)cJSON_malloc(prebuffer);"
"    if (!p.buffer)"
"    {"
"        return NULL;"
"    }"
"    p.length = prebuffer;"
"    p.offset = 0;"
""
"    return print_value(item, 0, fmt, &p);"
"}"
""
""
"/* Parser core - when encountering text, process appropriately. */"
"static const char *parse_value(cJSON *item, const char *value, const char **ep)"
"{"
"    if (!value)"
"    {"
"        /* Fail on null. */"
"        return NULL;"
"    }"
""
"    /* parse the different types of values */"
"    if (!strncmp(value, ""null"", 4))"
"    {"
"        item->type = cJSON_NULL;"
"        return value + 4;"
"    }"
"    if (!strncmp(value, ""false"", 5))"
"    {"
"        item->type = cJSON_False;"
"        return value + 5;"
"    }"
"    if (!strncmp(value, ""true"", 4))"
"    {"
"        item->type = cJSON_True;"
"        item->valueint = 1;"
"        return value + 4;"
"    }"
"    if (*value == "'\"""')"
"    {"
"        return parse_string(item, value, ep);"
"    }"
"    if ((*value == "'-"') || ((*value >= "'0"') && (*value <= "'9"')))"
"    {"
"        return parse_number(item, value);"
"    }"
"    if (*value == "'["')"
"    {"
"        return parse_array(item, value, ep);"
"    }"
"    if (*value == "'{"')"
"    {"
"        return parse_object(item, value, ep);"
"    }"
""
"    /* failure. */"
"    *ep = value;"
"    return NULL;"
"}"
""
"/* Render a value to text. */"
"static char *print_value(const cJSON *item, int depth, bool fmt, printbuffer *p)"
"{"
"    char *out = NULL;"
""
"    if (!item)"
"    {"
"        return NULL;"
"    }"
"    if (p)"
"    {"
"        switch ((item->type) & 0xFF)"
"        {"
"            case cJSON_NULL:"
"                out = ensure(p, 5);"
"                if (out)"
"                {"
"                    strcpy(out, ""null"");"
"                }"
"                break;"
"            case cJSON_False:"
"                out = ensure(p, 6);"
"                if (out)"
"                {"
"                    strcpy(out, ""false"");"
"                }"
"                break;"
"            case cJSON_True:"
"                out = ensure(p, 5);"
"                if (out)"
"                {"
"                    strcpy(out, ""true"");"
"                }"
"                break;"
"            case cJSON_Number:"
"                out = print_number(item, p);"
"                break;"
"            case cJSON_String:"
"                out = print_string(item, p);"
"                break;"
"            case cJSON_Array:"
"                out = print_array(item, depth, fmt, p);"
"                break;"
"            case cJSON_Object:"
"                out = print_object(item, depth, fmt, p);"
"                break;"
"        }"
"    }"
"    else"
"    {"
"        switch ((item->type) & 0xFF)"
"        {"
"            case cJSON_NULL:"
"                out = cJSON_strdup(""null"");"
"                break;"
"            case cJSON_False:"
"                out = cJSON_strdup(""false"");"
"                break;"
"            case cJSON_True:"
"                out = cJSON_strdup(""true"");"
"                break;"
"            case cJSON_Number:"
"                out = print_number(item, 0);"
"                break;"
"            case cJSON_String:"
"                out = print_string(item, 0);"
"                break;"
"            case cJSON_Array:"
"                out = print_array(item, depth, fmt, 0);"
"                break;"
"            case cJSON_Object:"
"                out = print_object(item, depth, fmt, 0);"
"                break;"
"        }"
"    }"
""
"    return out;"
"}"
""
"/* Build an array from input text. */"
"static const char *parse_array(cJSON *item,const char *value,const char **ep)"
"{"
"    cJSON *child = NULL;"
"    if (*value != "'["')"
"    {"
"        /* not an array! */"
"        *ep = value;"
"        return NULL;"
"    }"
""
"    item->type = cJSON_Array;"
"    value = skip(value + 1);"
"    if (*value == "']"')"
"    {"
"        /* empty array. */"
"        return value + 1;"
"    }"
""
"    item->child = child = cJSON_New_Item();"
"    if (!item->child)"
"    {"

"        /* memory fail */"
"        return NULL;"
"    }"
"    /* skip any spacing, get the value. */"
"    value = skip(parse_value(child, skip(value), ep));"
"    if (!value)"
"    {"
"        return NULL;"
"    }"
""
"    /* loop through the comma separated array elements */"
"    while (*value == "',"')"
"    {"
"        cJSON *new_item = NULL;"
"        if (!(new_item = cJSON_New_Item()))"
"        {"
"            /* memory fail */"
"            return NULL;"
"        }"
"        /* add new item to end of the linked list */"
"        child->next = new_item;"
"        new_item->prev = child;"
"        child = new_item;"
""
"        /* go to the next comma */"
"        value = skip(parse_value(child, skip(value + 1), ep));"
"        if (!value)"
"        {"
"            /* memory fail */"
"            return NULL;"
"        }"
"    }"
""
"    if (*value == "']"')"
"    {"
"        /* end of array */"
"        return value + 1;"
"    }"
""
"    /* malformed. */"
"    *ep = value;"
""
"    return NULL;"
"}"
""
"/* Render an array to text */"
"static char *print_array(const cJSON *item, int depth, bool fmt, printbuffer *p)"
"{"
"    char **entries;"
"    char *out = NULL;"
"    char *ptr = NULL;"
"    char *ret = NULL;"
"    int len = 5;"
"    cJSON *child = item->child;"
"    int numentries = 0;"
"    int i = 0;"
"    bool fail = false;"
"    size_t tmplen = 0;"
""
"    /* How many entries in the array? */"
"    while (child)"
"    {"
"        numentries++;"
"        child = child->next;"
"    }"
""
"    /* Explicitly handle numentries == 0 */"
"    if (!numentries)"
"    {"
"        if (p)"
"        {"
"            out = ensure(p, 3);"
"        }"
"        else"
"        {"
"            out = (char*)cJSON_malloc(3);"
"        }"
"        if (out)"
"        {"
"            strcpy(out,""[]"");"
"        }"
""
"        return out;"
"    }"
""
"    if (p)"
"    {"
"        /* Compose the output array. */"
"        /* opening square bracket */"
"        i = p->offset;"
"        ptr = ensure(p, 1);"
"        if (!ptr)"
"        {"
"            return NULL;"
"        }"
"        *ptr = "'["';"
"        p->offset++;"
""
"        child = item->child;"
"        while (child && !fail)"
"        {"
"            print_value(child, depth + 1, fmt, p);"
"            p->offset = update(p);"
"            if (child->next)"
"            {"
"                len = fmt ? 2 : 1;"
"                ptr = ensure(p, len + 1);"
"                if (!ptr)"
"                {"
"                    return NULL;"
"                }"
"                *ptr++ = "',"';"
"                if(fmt)"
"                {"
"                    *ptr++ = "' "';"
"                }"
"                *ptr = "'\0"';"
"                p->offset += len;"
"            }"
"            child = child->next;"
"        }"
"        ptr = ensure(p, 2);"
"        if (!ptr)"
"        {"
"            return NULL;"
"        }"
"        *ptr++ = "']"';"
"        *ptr = "'\0"';"
"        out = (p->buffer) + i;"
"    }"
"    else"
"    {"
"        /* Allocate an array to hold the pointers to all printed values */"
"        entries = (char**)cJSON_malloc(numentries * sizeof(char*));"
"        if (!entries)"
"        {"
"            return NULL;"
"        }"
"        memset(entries, "'\0"', numentries * sizeof(char*));"
""
"        /* Retrieve all the results: */"
"        child = item->child;"
"        while (child && !fail)"
"        {"
"            ret = print_value(child, depth + 1, fmt, 0);"
"            entries[i++] = ret;"
"            if (ret)"
"            {"
"                len += strlen(ret) + 2 + (fmt ? 1 : 0);"
"            }"
"            else"
"            {"
"                fail = true;"
"            }"
"            child = child->next;"
"        }"
""
"        /* If we didnt fail, try to malloc the output string */"
"        if (!fail)"
"        {"
"            out = (char*)cJSON_malloc(len);"
"        }"
"        /* If that fails, we fail. */"
"        if (!out)"
"        {"
"            fail = true;"
"        }"
""
"        /* Handle failure. */"
"        if (fail)"
"        {"
"            /* free all the entries in the array */"
"            for (i = 0; i < numentries; i++)"
"            {"
"                if (entries[i])"
"                {"
"                    cJSON_free(entries[i]);"
"                }"
"            }"
"            cJSON_free(entries);"
"            return NULL;"
"        }"
""
"        /* Compose the output array. */"
"        *out="'["';"
"        ptr = out + 1;"
"        *ptr = "'\0"';"
"        for (i = 0; i < numentries; i++)"
"        {"
"            tmplen = strlen(entries[i]);"
"            memcpy(ptr, entries[i], tmplen);"
"            ptr += tmplen;"
"            if (i != (numentries - 1))"
"            {"
"                *ptr++ = "',"';"
"                if(fmt)"
"                {"
"                    *ptr++ = "' "';"
"                }"
"                *ptr = "'\0"';"
"            }"
"            cJSON_free(entries[i]);"
"        }"
"        cJSON_free(entries);"
"        *ptr++ = "']"';"
"        *ptr++ = "'\0"';"
"    }"
""
"    return out;"
"}"
""
"/* Build an object from the text. */"
"static const char *parse_object(cJSON *item, const char *value, const char **ep)"
"{"
"    cJSON *child = NULL;"
"    if (*value != "'{"')"
"    {"
"        /* not an object! */"
"        *ep = value;"
"        return NULL;"
"    }"
""
"    item->type = cJSON_Object;"
"    value = skip(value + 1);"
"    if (*value == "'}"')"
"    {"
"        /* empty object. */"
"        return value + 1;"
"    }"
""
"    child = cJSON_New_Item();"
"    item->child = child;"
"    if (!item->child)"
"    {"
"        return NULL;"
"    }"
"    /* parse first key */"
"    value = skip(parse_string(child, skip(value), ep));"
"    if (!value)"
"    {"
"        return NULL;"
"    }"
"    /* use string as key, not value */"
"    child->string = child->valuestring;"
"    child->valuestring = NULL;"
""
"    if (*value != "':"')"
"    {"
"        /* invalid object. */"
"        *ep = value;"
"        return NULL;"
"    }"
"    /* skip any spacing, get the value. */"
"    value = skip(parse_value(child, skip(value + 1), ep));"
"    if (!value)"
"    {"
"        return NULL;"
"    }"
""
"    while (*value == "',"')"
"    {"
"        cJSON *new_item = NULL;"
"        if (!(new_item = cJSON_New_Item()))"
"        {"
"            /* memory fail */"
"            return NULL;"
"        }"
"        /* add to linked list */"
"        child->next = new_item;"
"        new_item->prev = child;"
""
"        child = new_item;"
"        value = skip(parse_string(child, skip(value + 1), ep));"
"        if (!value)"
"        {"
"            return NULL;"
"        }"
""
"        /* use string as key, not value */"
"        child->string = child->valuestring;"
"        child->valuestring = NULL;"
""
"        if (*value != "':"')"
"        {"
"            /* invalid object. */"
"            *ep = value;"
"            return NULL;"
"        }"
"        /* skip any spacing, get the value. */"
"        value = skip(parse_value(child, skip(value + 1), ep));"
"        if (!value)"
"        {"
"            return NULL;"
"        }"
"    }"
"    /* end of object */"
"    if (*value == "'}"')"
"    {"
"        return value + 1;"
"    }"
""
"    /* malformed */"
"    *ep = value;"
"    return NULL;"
"}"
""
"/* Render an object to text. */"
"static char *print_object(const cJSON *item, int depth, bool fmt, printbuffer *p)"
"{"
"    char **entries = NULL;"
"    char **names = NULL;"
"    char *out = NULL;"
"    char *ptr = NULL;"
"    char *ret = NULL;"
"    char *str = NULL;"
"    int len = 7;"
"    int i = 0;"
"    int j = 0;"
"    cJSON *child = item->child;"
"    int numentries = 0;"
"    bool fail = false;"
"    size_t tmplen = 0;"
""
"    /* Count the number of entries. */"
"    while (child)"
"    {"
"        numentries++;"
"        child = child->next;"
"    }"
""
"    /* Explicitly handle empty object case */"
"    if (!numentries)"
"    {"
"        if (p)"
"        {"
"            out = ensure(p, fmt ? depth + 4 : 3);"
"        }"
"        else"
"        {"
"            out = (char*)cJSON_malloc(fmt ? depth + 4 : 3);"
"        }"
"        if (!out)"
"        {"
"            return NULL;"
"        }"
"        ptr = out;"
"        *ptr++ = "'{"';"
"        if (fmt) {"
"            *ptr++ = "'\n"';"
"            for (i = 0; i < depth; i++)"
"            {"
"                *ptr++ = "'\t"';"
"            }"
"        }"
"        *ptr++ = "'}"';"
"        *ptr++ = "'\0"';"
""
"        return out;"
"    }"
""
"    if (p)"
"    {"
"        /* Compose the output: */"
"        i = p->offset;"
"        len = fmt ? 2 : 1; /* fmt: {\n */"
"        ptr = ensure(p, len + 1);"
"        if (!ptr)"
"        {"
"            return NULL;"
"        }"
""
"        *ptr++ = "'{"';"
"        if (fmt)"
"        {"
"            *ptr++ = "'\n"';"
"        }"
"        *ptr = "'\0"';"
"        p->offset += len;"
""
"        child = item->child;"
"        depth++;"
"        while (child)"
"        {"
"            if (fmt)"
"            {"
"                ptr = ensure(p, depth);"
"                if (!ptr)"
"                {"
"                    return NULL;"
"                }"
"                for (j = 0; j < depth; j++)"
"                {"
"                    *ptr++ = "'\t"';"
"                }"
"                p->offset += depth;"
"            }"
""
"            /* print key */"
"            print_string_ptr(child->string, p);"
"            p->offset = update(p);"
""
"            len = fmt ? 2 : 1;"
"            ptr = ensure(p, len);"
"            if (!ptr)"
"            {"
"                return NULL;"
"            }"
"            *ptr++ = "':"';"
"            if (fmt)"
"            {"
"                *ptr++ = "'\t"';"
"            }"
"            p->offset+=len;"
""
"            /* print value */"
"            print_value(child, depth, fmt, p);"
"            p->offset = update(p);"
""
"            /* print comma if not last */"
"            len = (fmt ? 1 : 0) + (child->next ? 1 : 0);"
"            ptr = ensure(p, len + 1);"
"            if (!ptr)"
"            {"
"                return NULL;"
"            }"
"            if (child->next)"
"            {"
"                *ptr++ = "',"';"
"            }"
""
"            if (fmt)"
"            {"
"                *ptr++ = "'\n"';"
"            }"
"            *ptr = "'\0"';"
"            p->offset += len;"
""
"            child = child->next;"
"        }"
""
"        ptr = ensure(p, fmt ? (depth + 1) : 2);"
"        if (!ptr)"
"        {"
"            return NULL;"
"        }"
"        if (fmt)"
"        {"
"            for (i = 0; i < (depth - 1); i++)"
"            {"
"                *ptr++ = "'\t"';"
"            }"
"        }"
"        *ptr++ = "'}"';"
"        *ptr = "'\0"';"
"        out = (p->buffer) + i;"
"    }"
"    else"
"    {"
"        /* Allocate space for the names and the objects */"
"        entries = (char**)cJSON_malloc(numentries * sizeof(char*));"
"        if (!entries)"
"        {"
"            return NULL;"
"        }"
"        names = (char**)cJSON_malloc(numentries * sizeof(char*));"
"        if (!names)"
"        {"
"            cJSON_free(entries);"
"            return NULL;"
"        }"
"        memset(entries, "'\0"', sizeof(char*) * numentries);"
"        memset(names, "'\0"', sizeof(char*) * numentries);"
""
"        /* Collect all the results into our arrays: */"
"        child = item->child;"
"        depth++;"
"        if (fmt)"
"        {"
"            len += depth;"
"        }"
"        while (child && !fail)"
"        {"
"            names[i] = str = print_string_ptr(child->string, 0); /* print key */"
"            entries[i++] = ret = print_value(child, depth, fmt, 0);"
"            if (str && ret)"
"            {"
"                len += strlen(ret) + strlen(str) + 2 + (fmt ? 2 + depth : 0);"
"            }"
"            else"
"            {"
"                fail = true;"
"            }"
"            child = child->next;"
"        }"
""
"        /* Try to allocate the output string */"
"        if (!fail)"
"        {"
"            out = (char*)cJSON_malloc(len);"
"        }"
"        if (!out)"
"        {"
"            fail = true;"
"        }"
""
"        /* Handle failure */"
"        if (fail)"
"        {"
"            /* free all the printed keys and values */"
"            for (i = 0; i < numentries; i++)"
"            {"
"                if (names[i])"
"                {"
"                    cJSON_free(names[i]);"
"                }"
"                if (entries[i])"
"                {"
"                    cJSON_free(entries[i]);"
"                }"
"            }"
"            cJSON_free(names);"
"            cJSON_free(entries);"
"            return NULL;"
"        }"
""
"        /* Compose the output: */"
"        *out = "'{"';"
"        ptr = out + 1;"
"        if (fmt)"
"        {"
"            *ptr++ = "'\n"';"
"        }"
"        *ptr = "'\0"';"
"        for (i = 0; i < numentries; i++)"
"        {"
"            if (fmt)"
"            {"
"                for (j = 0; j < depth; j++)"
"                {"
"                    *ptr++="'\t"';"
"                }"
"            }"
"            tmplen = strlen(names[i]);"
"            memcpy(ptr, names[i], tmplen);"
"            ptr += tmplen;"
"            *ptr++ = "':"';"
"            if (fmt)"
"            {"
"                *ptr++ = "'\t"';"
"            }"
"            strcpy(ptr, entries[i]);"
"            ptr += strlen(entries[i]);"
"            if (i != (numentries - 1))"
"            {"
"                *ptr++ = "',"';"
"            }"
"            if (fmt)"
"            {"
"                *ptr++ = "'\n"';"
"            }"
"            *ptr = "'\0"';"
"            cJSON_free(names[i]);"
"            cJSON_free(entries[i]);"
"        }"
""
"        cJSON_free(names);"
"        cJSON_free(entries);"
"        if (fmt)"
"        {"
"            for (i = 0; i < (depth - 1); i++)"
"            {"
"                *ptr++ = "'\t"';"
"            }"
"        }"
"        *ptr++ = "'}"';"
"        *ptr++ = "'\0"';"
"    }"
""
"    return out;"
"}"
""
"/* Get Array size/item / object item. */"
"int    cJSON_GetArraySize(const cJSON *array)"
"{"
"    cJSON *c = array->child;"
"    int i = 0;"
"    while(c)"
"    {"
"        i++;"
"        c = c->next;"
"    }"
"    return i;"
"}"
""
"cJSON *cJSON_GetArrayItem(const cJSON *array, int item)"
"{"
"    cJSON *c = array ? array->child : NULL;"
"    while (c && item > 0)"
"    {"
"        item--;"
"        c = c->next;"
"    }"
""
"    return c;"
"}"
""
"cJSON *cJSON_GetObjectItem(const cJSON *object, const char *string)"
"{"
"    cJSON *c = object ? object->child : NULL;"
"    while (c && cJSON_strcasecmp(c->string, string))"
"    {"
"        c = c->next;"
"    }"
"    return c;"
"}"
""
"bool cJSON_HasObjectItem(const cJSON *object,const char *string)"
"{"
"    return cJSON_GetObjectItem(object, string) ? 1 : 0;"
"}"
""
"/* Utility for array list handling. */"
"static void suffix_object(cJSON *prev, cJSON *item)"
"{"
"    prev->next = item;"
"    item->prev = prev;"
"}"
""
"/* Utility for handling references. */"
"static cJSON *create_reference(const cJSON *item)"
"{"
"    cJSON *ref = cJSON_New_Item();"
"    if (!ref)"
"    {"
"        return NULL;"
"    }"
"    memcpy(ref, item, sizeof(cJSON));"
"    ref->string = NULL;"
"    ref->type |= cJSON_IsReference;"
"    ref->next = ref->prev = NULL;"
"    return ref;"
"}"
""
"/* Add item to array/object. */"
"void   cJSON_AddItemToArray(cJSON *array, cJSON *item)"
"{"
"    cJSON *c = array->child;"
"    if (!item)"
"    {"
"        return;"
"    }"
"    if (!c)"
"    {"
"        /* list is empty, start new one */"
"        array->child = item;"
"    }"
"    else"
"    {"
"        /* append to the end */"
"        while (c->next)"
"        {"
"            c = c->next;"
"        }"
"        suffix_object(c, item);"
"    }"
"}"
""
"void   cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)"
"{"
"    if (!item)"
"    {"
"        return;"
"    }"
""
"    /* free old key and set new one */"
"    if (item->string)"
"    {"
"        cJSON_free(item->string);"
"    }"
"    item->string = cJSON_strdup(string);"
""
"    cJSON_AddItemToArray(object,item);"
"}"
""
"/* Add an item to an object with constant string as key */"
"void   cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)"
"{"
"    if (!item)"
"    {"
"        return;"
"    }"
"    if (!(item->type & cJSON_StringIsConst) && item->string)"
"    {"
"        cJSON_free(item->string);"
"    }"
"    item->string = (char*)string;"
"    item->type |= cJSON_StringIsConst;"
"    cJSON_AddItemToArray(object, item);"
"}"
""
"void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)"
"{"
"    cJSON_AddItemToArray(array, create_reference(item));"
"}"
""
"void cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)"
"{"
"    cJSON_AddItemToObject(object, string, create_reference(item));"
"}"
""
"cJSON *cJSON_DetachItemFromArray(cJSON *array, int which)"
"{"
"    cJSON *c = array->child;"
"    while (c && (which > 0))"
"    {"
"        c = c->next;"
"        which--;"
"    }"
"    if (!c)"
"    {"
"        /* item doesnt exist */"
"        return NULL;"
"    }"
"    if (c->prev)"
"    {"
"        /* not the first element */"
"        c->prev->next = c->next;"
"    }"
"    if (c->next)"
"    {"
"        c->next->prev = c->prev;"
"    }"
"    if (c==array->child)"
"    {"
"        array->child = c->next;"
"    }"
"    /* make sure the detached item doesnt point anywhere anymore */"
"    c->prev = c->next = NULL;"
""
"    return c;"
"}"
""
"void cJSON_DeleteItemFromArray(cJSON *array, int which)"
"{"
"    cJSON_Delete(cJSON_DetachItemFromArray(array, which));"
"}"
""
"cJSON *cJSON_DetachItemFromObject(cJSON *object, const char *string)"
"{"
"    int i = 0;"
"    cJSON *c = object->child;"
"    while (c && cJSON_strcasecmp(c->string,string))"
"    {"
"        i++;"
"        c = c->next;"
"    }"
"    if (c)"
"    {"
"        return cJSON_DetachItemFromArray(object, i);"
"    }"
""
"    return NULL;"
"}"
""
"void cJSON_DeleteItemFromObject(cJSON *object, const char *string)"
"{"
"    cJSON_Delete(cJSON_DetachItemFromObject(object, string));"
"}"
""
"/* Replace array/object items with new ones. */"
"void cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)"
"{"
"    cJSON *c = array->child;"
"    while (c && (which > 0))"
"    {"
"        c = c->next;"
"        which--;"
"    }"
"    if (!c)"
"    {"
"        cJSON_AddItemToArray(array, newitem);"
"        return;"
"    }"
"    newitem->next = c;"
"    newitem->prev = c->prev;"
"    c->prev = newitem;"
"    if (c == array->child)"
"    {"
"        array->child = newitem;"
"    }"
"    else"
"    {"
"        newitem->prev->next = newitem;"
"    }"
"}"
""
"void cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)"
"{"
"    cJSON *c = array->child;"
"    while (c && (which > 0))"
"    {"
"        c = c->next;"
"        which--;"
"    }"
"    if (!c)"
"    {"
"        return;"
"    }"
"    newitem->next = c->next;"
"    newitem->prev = c->prev;"
"    if (newitem->next)"
"    {"
"        newitem->next->prev = newitem;"
"    }"
"    if (c == array->child)"
"    {"
"        array->child = newitem;"
"    }"
"    else"
"    {"
"        newitem->prev->next = newitem;"
"    }"
"    c->next = c->prev = NULL;"
"    cJSON_Delete(c);"
"}"
""
"void cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)"
"{"
"    int i = 0;"
"    cJSON *c = object->child;"
"    while(c && cJSON_strcasecmp(c->string, string))"
"    {"
"        i++;"
"        c = c->next;"
"    }"
"    if(c)"
"    {"
"        /* free the old string if not const */"
"        if (!(newitem->type & cJSON_StringIsConst) && newitem->string)"
"        {"
"             cJSON_free(newitem->string);"
"        }"
""
"        newitem->string = cJSON_strdup(string);"
"        cJSON_ReplaceItemInArray(object, i, newitem);"
"    }"
"}"
""
"/* Create basic types: */"
"cJSON *cJSON_CreateNull(void)"
"{"
"    cJSON *item = cJSON_New_Item();"
"    if(item)"
"    {"
"        item->type = cJSON_NULL;"
"    }"
""
"    return item;"
"}"
""
"cJSON *cJSON_CreateTrue(void)"
"{"
"    cJSON *item = cJSON_New_Item();"
"    if(item)"
"    {"
"        item->type = cJSON_True;"
"    }"
""
"    return item;"
"}"
""
"cJSON *cJSON_CreateFalse(void)"
"{"
"    cJSON *item = cJSON_New_Item();"
"    if(item)"
"    {"
"        item->type = cJSON_False;"
"    }"
""
"    return item;"
"}"
""
"cJSON *cJSON_CreateBool(bool b)"
"{"
"    cJSON *item = cJSON_New_Item();"
"    if(item)"
"    {"
"        item->type = b ? cJSON_True : cJSON_False;"
"    }"
""
"    return item;"
"}"
""
"cJSON *cJSON_CreateNumber(double num)"
"{"
"    cJSON *item = cJSON_New_Item();"
"    if(item)"
"    {"
"        item->type = cJSON_Number;"
"        item->valuedouble = num;"
"        item->valueint = (int)num;"
"    }"
""
"    return item;"
"}"
""
"cJSON *cJSON_CreateString(const char *string)"
"{"
"    cJSON *item = cJSON_New_Item();"
"    if(item)"
"    {"
"        item->type = cJSON_String;"
"        item->valuestring = cJSON_strdup(string);"
"        if(!item->valuestring)"
"        {"
"            cJSON_Delete(item);"
"            return NULL;"
"        }"
"    }"
""
"    return item;"
"}"
""
"cJSON *cJSON_CreateArray(void)"
"{"
"    cJSON *item = cJSON_New_Item();"
"    if(item)"
"    {"
"        item->type=cJSON_Array;"
"    }"
""
"    return item;"
"}"
""
"cJSON *cJSON_CreateObject(void)"
"{"
"    cJSON *item = cJSON_New_Item();"
"    if (item)"
"    {"
"        item->type = cJSON_Object;"
"    }"
""
"    return item;"
"}"
""
"/* Create Arrays: */"
"cJSON *cJSON_CreateIntArray(const int *numbers, int count)"
"{"
"    int i = 0;"
"    cJSON *n = NULL;"
"    cJSON *p = NULL;"
"    cJSON *a = cJSON_CreateArray();"
"    for(i = 0; a && (i < count); i++)"
"    {"
"        n = cJSON_CreateNumber(numbers[i]);"
"        if (!n)"
"        {"
"            cJSON_Delete(a);"
"            return NULL;"
"        }"
"        if(!i)"
"        {"
"            a->child = n;"
"        }"
"        else"
"        {"
"            suffix_object(p, n);"
"        }"
"        p = n;"
"    }"
""
"    return a;"
"}"
""
"cJSON *cJSON_CreateFloatArray(const float *numbers, int count)"
"{"
"    int i = 0;"
"    cJSON *n = NULL;"
"    cJSON *p = NULL;"
"    cJSON *a = cJSON_CreateArray();"
"    for(i = 0; a && (i < count); i++)"
"    {"
"        n = cJSON_CreateNumber(numbers[i]);"
"        if(!n)"
"        {"
"            cJSON_Delete(a);"
"            return NULL;"
"        }"
"        if(!i)"
"        {"
"            a->child = n;"
"        }"
"        else"
"        {"
"            suffix_object(p, n);"
"        }"
"        p = n;"
"    }"
""
"    return a;"
"}"
""
"cJSON *cJSON_CreateDoubleArray(const double *numbers, int count)"
"{"
"    int i = 0;"
"    cJSON *n = NULL;"
"    cJSON *p = NULL;"
"    cJSON *a = cJSON_CreateArray();"
"    for(i = 0;a && (i < count); i++)"
"    {"
"        n = cJSON_CreateNumber(numbers[i]);"
"        if(!n)"
"        {"
"            cJSON_Delete(a);"
"            return NULL;"
"        }"
"        if(!i)"
"        {"
"            a->child = n;"
"        }"
"        else"
"        {"
"            suffix_object(p, n);"
"        }"
"        p = n;"
"    }"
""
"    return a;"
"}"
""
"cJSON *cJSON_CreateStringArray(const char **strings, int count)"
"{"
"    int i = 0;"
"    cJSON *n = NULL;"
"    cJSON *p = NULL;"
"    cJSON *a = cJSON_CreateArray();"
"    for (i = 0; a && (i < count); i++)"
"    {"
"        n = cJSON_CreateString(strings[i]);"
"        if(!n)"
"        {"
"            cJSON_Delete(a);"
"            return NULL;"
"        }"
"        if(!i)"
"        {"
"            a->child = n;"
"        }"
"        else"
"        {"
"            suffix_object(p,n);"
"        }"
"        p = n;"
"    }"
""
"    return a;"
"}"
""
"/* Duplication */"
"cJSON *cJSON_Duplicate(const cJSON *item, bool recurse)"
"{"
"    cJSON *newitem = NULL;"
"    cJSON *cptr = NULL;"
"    cJSON *nptr = NULL;"
"    cJSON *newchild = NULL;"
""
"    /* Bail on bad ptr */"
"    if (!item)"
"    {"
"        return NULL;"
"    }"
"    /* Create new item */"
"    newitem = cJSON_New_Item();"
"    if (!newitem)"
"    {"
"        return NULL;"
"    }"
"    /* Copy over all vars */"
"    newitem->type = item->type & (~cJSON_IsReference);"
"    newitem->valueint = item->valueint;"
"    newitem->valuedouble = item->valuedouble;"
"    if (item->valuestring)"
"    {"
"        newitem->valuestring = cJSON_strdup(item->valuestring);"
"        if (!newitem->valuestring)"
"        {"
"            cJSON_Delete(newitem);"
"            return NULL;"
"        }"
"    }"
"    if (item->string)"
"    {"
"        newitem->string = cJSON_strdup(item->string);"
"        if (!newitem->string)"
"        {"
"            cJSON_Delete(newitem);"
"            return NULL;"
"        }"
"    }"
"    /* If non-recursive, then we are done! */"
"    if (!recurse)"
"    {"
"        return newitem;"
"    }"
"    /* Walk the ->next chain for the child. */"
"    cptr = item->child;"
"    while (cptr)"
"    {"
"        newchild = cJSON_Duplicate(cptr, 1); /* Duplicate (with recurse) each item in the ->next chain */"
"        if (!newchild)"
"        {"
"            cJSON_Delete(newitem);"
"            return NULL;"
"        }"
"        if (nptr)"
"        {"
"            /* If newitem->child already set, then crosswire ->prev and ->next and move on */"
"            nptr->next = newchild;"
"            newchild->prev = nptr;"
"            nptr = newchild;"
"        }"
"        else"
"        {"
"            /* Set newitem->child and move to it */"
"            newitem->child = newchild; nptr = newchild;"
"        }"
"        cptr = cptr->next;"
"    }"
""
"    return newitem;"
"}"
""
"void cJSON_Minify(char *json)"
"{"
"    char *into = json;"
"    while (*json)"
"    {"
"        if (*json == "' "')"
"        {"
"            json++;"
"        }"
"        else if (*json == "'\t"')"
"        {"
"            /* Whitespace characters. */"
"            json++;"
"        }"
"        else if (*json == "'\r"')"
"        {"
"            json++;"
"        }"
"        else if (*json=="'\n"')"
"        {"
"            json++;"
"        }"
"        else if ((*json == "'/"') && (json[1] == "'/"'))"
"        {"
"            /* double-slash comments, to end of line. */"
"            while (*json && (*json != "'\n"'))"
"            {"
"                json++;"
"            }"
"        }"
"        else if ((*json == "'/"') && (json[1] == "'*"'))"
"        {"
"            /* multiline comments. */"
"            while (*json && !((*json == "'*"') && (json[1] == "'/"')))"
"            {"
"                json++;"
"            }"
"            json += 2;"
"        }"
"        else if (*json == "'\"""')"
"        {"
"            /* string literals, which are \ sensitive. */"
"            *into++ = *json++;"
"            while (*json && (*json != "'\"""'))"
"            {"
"                if (*json == "'\\"')"
"                {"
"                    *into++=*json++;"
"                }"
"                *into++ = *json++;"
"            }"
"            *into++ = *json++;"
"        }"
"        else"
"        {"
"            /* All other characters. */"
"            *into++ = *json++;"
"        }"
"    }"
""
"    /* and null-terminate. */"
"    *into = "'\0"';"
"}"], fd);

    mclose(fd);

endfunction
